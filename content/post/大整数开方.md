---
title: "大整数开方"
date: 2016-01-30
draft: false
tags: ["OI", "高精度"]
# categories: ["docs", "shortcodes", "index"]
author: "Tom Smith"
---

> 输入一个正整数N(1≤N≤10^100 )，试用二分法计算它的平方根的整数部分。

题目非常明显，连方法都告诉你了，就是实现一个高精度，二分答案。高精度要实现，加法、除以二、二次方、比较。几乎把高精度操作都实现了一遍，不过因为乘法和除法分别是二次方和除以二，还是比较简单的。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm> 
#define N 105	//数字最长，如果用vector存则不需要 
using namespace std;
struct Big{
	int num[N];//num[0]为数字位数，num[1-N-1]为数字每一位 
	/*各种初始化*/ 
	Big(){
		memset(num,0,sizeof(num));
		num[0]=1;
	}
	Big(char *s){
		start(s);
	}
	Big(const Big *a){
		for(int i=0;i<N;i++){ 
			num[i]=a->num[i];
		}
	}
	/*读入处理*/
	void read(){
		char ss[N];
		scanf("%s",ss);
		start(ss);
	}
	void start(char *ss){
		num[0]=strlen(ss);
		for(int i=1;i<=num[0];i++){//反着存数字便于计算 
			num[i]=ss[num[0]-i]-'0';
		}
		for(;!num[num[0]]&&num[0]-1;num[0]--){
		//删除前导0  防止Big a="00000000001"这种情况出现 
		}
	}
	/*比较函数*/
	int big(Big a){	//大于等于返回1，小于返回0。
			//对后面二分有重要作用 
		if(num[0]>a.num[0]){
			return 1;
		}else if(num[0]<a.num[0]){ 
			return 0; 
		} 
		for(int i=num[0];i>=1;i--){
			if(num[i]>a.num[i]){
				return 1;
			}else if(num[i]<a.num[i]){
				return 0;
			}
		}
		return 1;
	}
	/*自增自减操作*/ 
	void minmin(){
		int i;
		for(i=1;num[i]==0;i++){
			num[i]=9;
		}
		num[i]--;
		if(!num[num[0]]){
			num[0]--;
		}
	}
	void plusplus(){
		int i;
		for(i=1;num[i]==9;i++){
			num[i]=0;
		}
		num[i]++;
		if(num[num[0]+1]){
			num[0]++;
		}
	}
}a,b,c; 
void swap(Big &a,Big &b){
	Big c=a;
	a=b;
	b=c;
}
/*加法*/ 
Big add(Big a,Big b){
	Big c;
	c.num[0]=max(a.num[0],b.num[0]);
	for(int i=1;i<=c.num[0];i++){
		c.num[i]+=a.num[i]+b.num[i];
		c.num[i+1]=c.num[i]/10;
		c.num[i]%=10;
	}
	if(c.num[c.num[0]+1]){
		c.num[0]++;
	}
	return c;
}
/*乘法，这里实现的是完整的大整数乘法*/ 
Big mul(Big b,Big a){
	Big c;
	for(int i=1;i<=a.num[0];i++){
		for(int j=1;j<=b.num[0];j++){ 
			c.num[i+j-1]+=a.num[i]*b.num[j]; 
			c.num[i+j]+=c.num[i+j-1]/10; 
			c.num[i+j-1]%=10; 
		} 
	} 
	c.num[0]=a.num[0]+b.num[0]; //999*99=98901 100*10=1000 
			//最多长度为两个相加，最短为两个相加减一 
	if(!c.num[c.num[0]]){ 
		c.num[0]--; 
	} 
	return c; 
}
/*除法，这里实现的是除以二*/ 
Big div(Big b){ 
	for(int i=b.num[0];i>1;i--){
		b.num[i-1]+=10*(b.num[i]%2);
		//模拟人工除法结果取整数部分 
		b.num[i]/=2;
	}
	b.num[1]/=2;
	if(!b.num[b.num[0]]&&b.num[0]!=1){
		b.num[0]--;
	}
	return b;
}
int main(void){
	c.read();
	b.num[0]=51;
	b.num[51]=1;
	a.num[0]=1;
	while(b.big(a)){
		Big temp=div(add(b,a));
		Big ff=mul(temp,temp);
		//二分条件还有左右值的改变要思考清楚 
		if(ff.big(c)){
			temp.minmin();
			b=temp;
		}else{
			temp.plusplus();
			a=temp;
		}
	}
	b.print();
	return 0;
}
```